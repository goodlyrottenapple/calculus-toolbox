---
layout: page
title: "Scala UI"
category: doc
date: 2015-04-10 09:09:57
---

### UI Overview
After generating the calculus and recompiling all the UI classes, running `make gui` inside the generated calculus should produce the window below.

![scala gui screenshot](https://raw.githubusercontent.com/goodlyrottenapple/calculus-toolbox/gh-pages/_files/scala_gui_screen1.png)

The bar at the top, containing the text input field, is used by the user to input sequents into the UI. The user uses ASCII and if the input can be parsed, it is [typeset](#latex-typesetting) in LaTeX for better readability. Pressing Enter after the user entered a valid sequent will launch the [proof search](#proof-search). If the proof search is successful, the resulting proof tree found is displayed in the panel below. The UI allows the user to interactively modify the proof trees by clicking on any of the sequents in the tree:

![scala gui screenshot, pt close up](https://raw.githubusercontent.com/goodlyrottenapple/calculus-toolbox/gh-pages/_files/scala_gui_screen2.png)


Each sequent in the proof tree can be clicked on and the proof tree can be modified at this point. The options, listed in the drop down menu shown above, are described in more detail in the following table:

{: .table .table-responsive}
Copy                  | Copies the selected sequent as an ASCII string
Add&nbsp;as&nbsp;assm | Adds the selected sequent to the list of assumptions
Merge&nbsp;above      | Looks at all the generated proof trees in the session (shown in a list on the right), searching for a proof tree with a conclusion which matches the selected sequent. If such a proof tree is found, it is copied into the current one and merged at the selected sequent. Note that the selected sequent must be a leaf of the tree. (To make the selected sequent a leaf, use the option `Delete above`)
FindPT                | This option will start a [proof search](#proof-search) with the selected sequent as the goal/target. If a proof tree is found, it is automatically added into the current proof tree.
Add&nbsp;above        | If the selected sequent is a leaf in the proof tree, add above will open a dialog window with a list of all the possible derivations for the selected sequent:<br>![scala gui screenshot, pt close up](https://raw.githubusercontent.com/goodlyrottenapple/calculus-toolbox/gh-pages/_files/scala_gui_screen3.png)<br>Selecting a rule form the list will apply the rule to the selected sequent and derive the premises, adding them to the tree.
Add&nbsp;below        | If the selected sequent is at the root of the tree, this option will allow the user to grow the tree downwards, i.e. to generate a proof tree for a different conclusion by extending the current proof tree downwards. A prompt for the new conclusion will be displayed, and if a rule is found that can derive the current conclusion from the new one, the new conclusion will be added as the root of the tree.
Delete&nbsp;above     | Delete above simply removes any part of the proof tree above the current sequent and turns the current sequent into a premise
Delete&nbsp;below     | Delete below removes any part of the proof tree below the current sequent, making the current sequent the root/conclusion of the proof tree
Apply&nbsp;Cut        | If the calculus contains the cut rule (more specifically SingleCut), this option will prompt the user for a cut formula and then try to apply [proof search](#proof-search) to the two new branches introduced by the cut rule. If one or both proof trees cannot be found, that branch/branches will be added as a premise.


Next in in main screen is the side bar on the right. This sidebar contains all the assumptions and proof trees in this session as well as the loaded up macros. The proof trees and assumptions can be saved into a text file and loaded back up into the UI (Use __File__ > __Open...__ and __File__ > __Save/Save As...__ ). 

To add a sequent as an assumption, first type the sequent into the text input at the top and when the sequent is parsed, click on the `Add assm` button underneath the assumption list.

<table class="table" markdown="0">
<tr>
<td><span class="glyphicon glyphicon-exclamation-sign"></span></td>
<td markdown="1">
In order to use assumptions in the `der` function and by extension the proof search, the `Prem` rule must be added to the JSON file. To do this, add the following declaration to the `calc_structure_rules` under `RuleZer`:

{% highlight json %}
"Prem" : {
    "ascii" : "Prem",
    "latex" : "Prem",
    "condition" : "(\\<lambda>x. seq = x)",
    "locale" : "Premise seq"
}
{% endhighlight %}

and

{% highlight json %}
"Prem" : ["?X |- ?Y", ""]
{% endhighlight %}

to `RuleZer` in `rules`. This is assuming that the type `Locale` has a constructor `Premise Sequent`.
</td>
</tr>
</table>

The proof tree list holds all the added proof trees. To switch between them, simply double click on a proof tree in the list (the list labels are the conclusion sequents of each proof tree). Right clicking on an individual proof tree brings up the following drop-down menu:

![scala gui screenshot, pt list drop down menu](https://raw.githubusercontent.com/goodlyrottenapple/calculus-toolbox/gh-pages/_files/scala_gui_screen4.png)

{: .table .table-responsive}
Add&nbsp;as&nbsp;assm       | Adds the root sequent of the selected proof tree to the list of assumptions
Delete                      | Deletes the selected proof tree (you can also delete a proof tree/list of proof trees by highlighting and pressing the Delete key on the keyboard )
Export&nbsp;to&nbsp;LaTeX   | Prompts the user to select a file name and then exports the selected proof tree to latex (the proof tree type setting requires [bussproofs.sty](http://math.ucsd.edu/~sbuss/ResearchWeb/bussproofs/))
Copy&nbsp;as&nbsp;Isabelle  | Copies the entire proof tree into the clipboard (as a string). This proof tree can be pasted into an Isabelle theory file.
Create&nbsp;Rule&nbsp;Macro | Creates a macro form the selected prooftree. For more information, read the section on [locales](#locales-and-relaka).

Finally, the bottom bar contains buttons for loading locales and relAKA, if these are defined in the calculus. The specifics on [locales and relAKA](#locales-and-relaka) are documented in a separate section below. The `PT search depth` spinner sets the depth of the [proof tree search](#proof-search). The value of 5 returns a result in a reasonable time and as the search time for each extra level is roughly exponential, the search times past the value 7 are usually not practical.

The `Valid Prooftree` label indicates if the proof tree is valid, by running the `isProoftree` function every time the proof tree is changed or reloaded.

### LaTeX Typesetting

A big motivation for the UI tools was the difficult readability of the encoded calculus. The full D.EAK calculus, even with syntactic sugar, is already quite far removed form the LaTeX representation, however the real trouble comes with the encoding of the proof trees.

For demonstration, this is an encoding of a proof tree in Isabelle:
<pre>
<code> (Atprop ''p'' <sub>F</sub> <sub>S</sub> ⊢<sub>S</sub> B<sub>S</sub> Atprop ''p'' <sub>F</sub> <sub>S</sub> ;<sub>S</sub> Atprop ''q'' <sub>F</sub> <sub>S</sub>) ⟸ PT  RuleDisp ImpR_comma_disp2 [(B<sub>S</sub> Atprop ''p'' <sub>F</sub> <sub>S</sub> →<sub>S</sub> Atprop ''p'' <sub>F</sub> <sub>S</sub> ⊢<sub>S</sub> Atprop ''q'' <sub>F</sub> <sub>S</sub>) ⟸ PT  RuleStruct W_impR_L [(Atprop ''p'' <sub>F</sub> <sub>S</sub> ⊢<sub>S</sub> Atprop ''p'' <sub>F</sub> <sub>S</sub>) ⟸ PT  RuleZer RuleZer.Id  []]]</code>
</pre>

Even after formatting and lining up the code snippet above, the coding is still quite hard to read:

<pre>
<code> (Atprop ''p'' <sub>F</sub> <sub>S</sub> ⊢<sub>S</sub> B<sub>S</sub> Atprop ''p'' <sub>F</sub> <sub>S</sub> ;<sub>S</sub> Atprop ''q'' <sub>F</sub> <sub>S</sub>) ⟸ PT  RuleDisp ImpR_comma_disp2  
[(B<sub>S</sub> Atprop ''p'' <sub>F</sub> <sub>S</sub> →<sub>S</sub> Atprop ''p'' <sub>F</sub> <sub>S</sub> ⊢<sub>S</sub> Atprop ''q'' <sub>F</sub> <sub>S</sub>) ⟸ PT  RuleStruct W_impR_L
                      [(Atprop ''p'' <sub>F</sub> <sub>S</sub> ⊢<sub>S</sub> Atprop ''p'' <sub>F</sub> <sub>S</sub>) ⟸ PT  RuleZer RuleZer.Id  []]]</code>
</pre>

When typeset in LaTeX however, the proof is readable immediately:

$$\frac{\displaystyle \frac
{p \vdash p}
{p > p \vdash q} }
{p \vdash p ; q}$$

Due of this, the UI was initially developed with the express intention of pretty printing the proof trees generated by the [proof search](#proof-search) algorithm. The reasons Scala was used for the UI were two fold. The main reason Scala was chosen was due to the fact that the code export tool in Isabelle supported exporting code to Scala. The second reason, tied to the need for a UI and LaTeX typesetting, was the ability of Scala to import and use Java libraries.  
The library used for LaTeX typesetting of the calculus terms is [JLaTeXMath](http://forge.scilab.org/index.php/p/jlatexmath/). The library includes a subset of the available LaTeX packages and has so far been sufficient for all typesetting. The advantage of the library is the complete independence of the system version of LaTeX, as it is self contained. However, this library does not contain the [bussproofs.sty](http://math.ucsd.edu/~sbuss/ResearchWeb/bussproofs/) style sheet. This meant that the proof trees inside the UI had to be laid out without the use of LaTeX. Another library, [TreeLayout](http://treelayout.sourceforge.net/), was used to layout the individual sequents into a proof tree in the UI. This approach, whilst more complicated than using LaTeX typesetting of the full proof trees, allowed for the easy addition of interactivity to the proof trees by adding context menus, as seen in the section above.

### Proof search

### Locales and relAKA
