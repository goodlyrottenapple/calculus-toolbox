The calculus toolbox has been designed around a special class of logics
called \emph{display calculi}, first introduced by Nuel Belnap as
Display Logic. These logics are easily modified and extended, meaning
that this toolbox, which is based around the aforementioned calculi can
be very flexible.

The need for a toolbox for display calculi arose from the formalization
of set calculi in the theorem prover Isabelle. The initial
implementation of was a minimal calculus adapted from the D.EAK calculus
described in the paper by A.Kurz, et al. This version of the calculus
only contained a small subset of rules and connectives of the full
calculus and was used to test out the implementation of such calculi in
Isabelle.

Initially, a shallow embedding (abbreviated SE) of the calculus was
formalized in Isabelle, however, with the aim of formalizing the cut
elimination proof for the D.EAK calculus, it was soon discovered that
the SE would not be sufficient and a deep embedding (abbreviated DE) of
the calculus would be needed.

\subsubsection{Basic Structure of a display
calculus}\label{basic-structure-of-a-display-calculus}

The terms of the minimal display calculus are inductively built from
atomic propositions, composed into formulas, which are in turn composed
into structures. a valid term of a calculus is a sequent composed of two
structures on either side of a turnstile: $X \vdash Y$, with the left
structure $X$ referred to as the antecedent of the sequent and the right
part $Y$ being the consequent/succedent. The definitions of the minimal
calculus formula and structure terms are given below:

\{:.table .noborder .centering .equal-cols-2\} \textbar{}
$F:= ap \in \mathsf{AtProp} \mid F \land F \mid F \rightarrow F$
\textbar{} $S:= F \mid \mathsf{Id} \mid S \,; S \mid S > S$ \textbar{}

\subsubsection{Shallow embedding}\label{shallow-embedding}

Both the shallow and the deep embedding follow a similar structure of
formalization in Isabelle. Firstly, there is the inductive definition of
the terms of the calculus, formalized via Isabelle's \texttt{datatype}
definition (formula terms defined in the previous section):

\begin{verbatim}
datatype formula = Atprop atProp
                 | And_F formula formula  (infix "∧F" 570)
                 | ImpR_F formula formula (infix "→F" 550)
\end{verbatim}

Whereas in the abstract definition, the set of atomic propositions is
not specifically defined, in the SE, we have chosen to use strings for
atomic propositions:

\begin{Shaded}
\begin{Highlighting}[]
\ErrorTok{type_synonym} \ErrorTok{atProp} \ErrorTok{=} \ErrorTok{string}
\end{Highlighting}
\end{Shaded}

To keep things easily readable even in the Isabelle notation, syntactic
sugar is introduced via the \texttt{infix} keyword, which allows infix
syntax for the constructors of the Formula datatype.\\Thus, a simple
formula such as $p \land p$, written as
\texttt{And\_F (Atprop ’’p’’) (Atprop ’’p’’)} in Isabelle syntax without
the syntactic sugar, can also be written as
\texttt{Atprop ’’p’’ ∧F Atprop ’’p’’} using the infix \texttt{∧F}
constructor, instead of the \texttt{And\_F} one.\\Structures and
Sequents of the calculus have been formalized in the SE in a similar
fashion.

The next important part of the formalization is the notion of
derivability of a sequent in a calculus. Isabelle provides facilities
for inductively defining derivability through the \texttt{inductive}
definition (note the following code snippet is not the full definition
of derivable in the minimal calculus):

\begin{verbatim}
inductive derivable :: "sequent ⇒ bool" ("⊢d _" 300)
where
    Id: "⊢d Form (Atprop p) ⊢ Form (Atprop p)"
  | I_impR: " ⊢d (X ⊢ Y) ⟹ ⊢d (I ⊢ X>>Y)"
  | I_impR2: " ⊢d (I ⊢ X>>Y) ⟹ ⊢d (X ⊢ Y)"
  | ImpR_I: " ⊢d (X ⊢ Y) ⟹ ⊢d (Y>>X ⊢ I)"
  | ImpR_I2: " ⊢d (Y>>X ⊢ I) ⟹ ⊢d (X ⊢ Y)"
  | IW_L: " ⊢d (I ⊢ X) ⟹ ⊢d (Y ⊢ X)"
  | IW_R: " ⊢d (X ⊢ I) ⟹ ⊢d (X ⊢ Y)"
  ...
\end{verbatim}

\subsubsection{Deep embedding}\label{deep-embedding}

Whilst the core SE implementation is quite short, it lacks features
needed for the cut elimination proof, namely an explicit notion of proof
trees.\\Even though a derivable sequent always has a derivation tree, in
SE, this tree is only implicitly encoded in Isabelle and cannot be
accessed easily.\\The inductive definition of the rules in the SE
automatically generate rewrite rules of the same form, using Isabelle
meta-variables along with the internal Isabelle pattern matching and
rule application. Since these mechanisms are embedded deep within
Isabelle's core, they are not easy to reason about and manipulate
explicitly, as seen below in the proof tree for the derived weakening
rule in the minimal calculus:

\[\frac{\displaystyle \frac
{X \vdash Y}
{Y > X \vdash Z} }
{X \vdash Y ; Z}\]

Note that since the proof tree is derived bottom-to-top, but we write
proofs top-to-bottom in a text editor, the Isabelle proof is inverted:

\begin{Shaded}
\begin{Highlighting}[]
\ErrorTok{lemma} \ErrorTok{W_R:} 
\ErrorTok{assumes} \ErrorTok{"⊢d} \ErrorTok{X} \ErrorTok{⊢} \ErrorTok{Y"}
\ErrorTok{shows} \ErrorTok{"⊢d} \ErrorTok{X} \ErrorTok{⊢} \ErrorTok{Y;Z"}              \ErrorTok{(*} \ErrorTok{goal:} \ErrorTok{⊢d} \ErrorTok{X} \ErrorTok{⊢} \ErrorTok{Y;Z}  \ErrorTok{*)}
\ErrorTok{apply} \ErrorTok{(rule} \ErrorTok{ImpR_comma_disp2)}   \ErrorTok{(*} \ErrorTok{goal:} \ErrorTok{⊢d} \ErrorTok{Y>>X} \ErrorTok{⊢} \ErrorTok{Z} \ErrorTok{*)}
\ErrorTok{apply} \ErrorTok{(rule} \ErrorTok{W_impR_L)}           \ErrorTok{(*} \ErrorTok{goal:} \ErrorTok{⊢d} \ErrorTok{X} \ErrorTok{⊢} \ErrorTok{Y}    \ErrorTok{*)}
\ErrorTok{apply} \ErrorTok{(rule} \ErrorTok{assms)}              \ErrorTok{(*} \ErrorTok{done}              \ErrorTok{*)}
\end{Highlighting}
\end{Shaded}

Since the notion of a proof tree in SE is very abstract as it is encoded
using Isabelle's own proof environment, and the cut elimination proof
for the display calculi needs an explicit way of manipulating proof
trees, the DE version of the calculus introduces a different encoding
that allows explicit reasoning with and manipulation of proof trees.\\In
order to encode proof trees, the notion of derivability had to be
rewritten more explicitly.

A proof tree in the DE is a recursively defined term (using Isabelle's
\texttt{datatype}), just like a sequent or a formula, containing a
sequent and the accompanying rule that was applied to obtain it at its
conclusion/root and sub-trees of previous steps/derivations forming its
branches. All the leaves of the proof tree must contain valid axioms (in
the minimal calculus, this means the \emph{Id} rule).

The validity of such proof tree is determined by checking the derivation
of the conclusion of every sub-tree from its branches. Since the data
structure encoding these proof trees carries no notion of validity, a
method \emph{isProofTree} is introduced alongside the general proof tree
definition. The \emph{isProofTree} function recursively traverses a
given tree and checks that the rules have been applied correctly at each
level. A valid proof tree of a DE sequent is, in essence, an encoding of
an Isabelle proof one would need to write in the SE to show derivability
for the equivalent SE sequent.

The explicit application of rules to sequents in the \emph{isProofTree}
function introduces the need for explicit pattern matching of sequents
and rules and that means, firstly, the introduction of free variables to
the data structures of the SE.\\In the DE, we introduce a new
constructor for each type from the SE. For example, an atomic
proposition in DE will now have two terms, the original one
(\emph{Atprop}) and an extra free variable term
(\emph{Atprop\_Freevar}).

\begin{center}\rule{3in}{0.4pt}\end{center}

As well as introducing free variables to the formulas and structures,
the DE of these terms has been made more parametric, separating the
constructors for the \emph{n}-ary connectives, to allow easier extension
of these calculi (for example, the minimal calculus mainly differs from
the full D.EAK calculus in the number of nullary, unary and binary
connectives and rules ranging over them). The encoding of structure
terms is now separated out into several definitions:

\begin{Shaded}
\begin{Highlighting}[]
\ErrorTok{datatype} \ErrorTok{Structure_ZerOp} \ErrorTok{=} \ErrorTok{Structure_Neutral}
 
\ErrorTok{datatype} \ErrorTok{Structure_BinOp} \ErrorTok{=} \ErrorTok{Structure_Comma}
                         \ErrorTok{|} \ErrorTok{Structure_ImpR}

\ErrorTok{datatype} \ErrorTok{Structure} \ErrorTok{=} \ErrorTok{Structure_Formula} \ErrorTok{Formula}
                   \ErrorTok{|} \ErrorTok{Structure_Zer} \ErrorTok{Structure_ZerOp}
                   \ErrorTok{|} \ErrorTok{Structure_Bin} \ErrorTok{Structure} \ErrorTok{Structure_BinOp} \ErrorTok{Structure}
                   \ErrorTok{|} \ErrorTok{Structure_Freevar} \ErrorTok{string}
\end{Highlighting}
\end{Shaded}

Note, that this encoding of the calculus also includes syntactic sugar
notation of its terms to make them more concise and closer to the SE
version, however the declaration of this notation has been omitted from
the code snippet above for better readability.

\begin{center}\rule{3in}{0.4pt}\end{center}

Next, the notion of pattern-matching and derivation/rewriting of
sequents through rule application needed to be encoded explicitly. The
functions \emph{match} and \emph{replace}/\emph{replaceAll} are matching
functions that disassemble and reassemble a term of the calculus
according to a template/rule.

The \emph{match} function takes two terms; the first one is a concrete
term and the second the rule containing free variables. The function
then tries to match the free variables of the second term to sub-terms
in the first expression, returning a list of the matched pairs. If the
two terms cannot be matched against each other, i.e.~have different
structures, \emph{match} will only return a list of partial matches
which did not clash (or possibly even an empty list).

The \emph{replaceAll} function is the converse of the \emph{match}
function, taking a list of matched pairs and a template/rule term and
substituting the free variables in the rule with matched sub-terms from
the list (The \emph{replaceAll} function calls the \emph{replace}
function (which only replaces one pair in a given rule) repeatedly for
the whole list).

For instance, the sequent $?X \vdash ?Y$, where $?X$ and $?Y$ represent
free variables, can be matched against $p \land p \vdash q$, wherein
$?X$ will be matched to $p \land p$ and $?Y$ will be matched to $q$. The
actual list returned by applying match to these two sequents would look
like this:

\begin{center}\rule{3in}{0.4pt}\end{center}

Notice the \texttt{Sequent\_Structure} constructor that has no sugar
syntax. This constructor is only used by \emph{match} and
\emph{replace}/\emph{replaceAll}. This constroctor was introduced to the
DE due to the constraints of the class system in Isabelle, which does
not allow polymorphism over functions with multiple type signatures and
is in itself not a valid term of the calculus. However, the constructors
\texttt{Structure\_Formula} and \texttt{Formula\_Atprop} which are part
of the calculus take on a similar use in the \emph{match} and
\emph{replace}/\emph{replaceAll} functions. To get a better idea of what
happens in these functions have a look at the
\href{https://github.com/goodlyrottenapple/calculus-toolbox/blob/master/template/Calc_Core.thy}{core
calculus template}.

\begin{center}\rule{3in}{0.4pt}\end{center}

Finally, passing this list above to the \emph{replaceAll} function and
applying it to the rule $I \vdash ?X \rightarrow ?Y$ will replace the
free variable $?X$ with $p \land p$ and $?Y$ with $q$, yielding
$I \vdash (p \land p) \rightarrow q$.

The way the match function is defined allows for matching a rule ?X ?Y
to a sequent ?Y `?Z. Even though the application of match to these two
sequents would introduce a conflict in the free variable names (where
the order of applying the replace back into a rule would potentially
result in two different sequents), match is only meant to match terms
with no free variables to rules. This is enforced by always checking
that the first sequent contains no free variables before matching it to
the rule. This condition is not enforced in the rule application itself,
but is instead included in the definitions that use match as a guard
before each application of match. Care must therefore be taken that this
condition is met and enforced at the right times.

The der function in DE combines all the previous functions and the rule
definitions and given a rule and a sequent, it will first check the rule
is applicable and if so, will match the sequent with the rule and
replace the matched substructures for the free variables of the rule
conclusion (or conclusions for binary/ternary/etc. rules).
